<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html><head><title>module ti.sysbios.knl.Clock</title>
<meta name="googlebot" content="noindex,nofollow">
<link rel="stylesheet" type="text/css" href="../../../src.css"/>
</head>
<body>
<pre class=src>
     1    <span class="comment">/* 
</span>     2    <span class="comment"> * Copyright (c) 2012, Texas Instruments Incorporated
</span>     3    <span class="comment"> * All rights reserved.
</span>     4    <span class="comment"> *
</span>     5    <span class="comment"> * Redistribution and use in source and binary forms, with or without
</span>     6    <span class="comment"> * modification, are permitted provided that the following conditions
</span>     7    <span class="comment"> * are met:
</span>     8    <span class="comment"> *
</span>     9    <span class="comment"> * *  Redistributions of source code must retain the above copyright
</span>    10    <span class="comment"> *    notice, this list of conditions and the following disclaimer.
</span>    11    <span class="comment"> *
</span>    12    <span class="comment"> * *  Redistributions in binary form must reproduce the above copyright
</span>    13    <span class="comment"> *    notice, this list of conditions and the following disclaimer in the
</span>    14    <span class="comment"> *    documentation and/or other materials provided with the distribution.
</span>    15    <span class="comment"> *
</span>    16    <span class="comment"> * *  Neither the name of Texas Instruments Incorporated nor the names of
</span>    17    <span class="comment"> *    its contributors may be used to endorse or promote products derived
</span>    18    <span class="comment"> *    from this software without specific prior written permission.
</span>    19    <span class="comment"> *
</span>    20    <span class="comment"> * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
</span>    21    <span class="comment"> * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
</span>    22    <span class="comment"> * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
</span>    23    <span class="comment"> * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR
</span>    24    <span class="comment"> * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
</span>    25    <span class="comment"> * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
</span>    26    <span class="comment"> * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS;
</span>    27    <span class="comment"> * OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
</span>    28    <span class="comment"> * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR
</span>    29    <span class="comment"> * OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
</span>    30    <span class="comment"> * EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
</span>    31    <span class="comment"> * */</span>
    32    <span class="comment">/*
</span>    33    <span class="comment"> *  ======== Clock.xdc ========
</span>    34    <span class="comment"> *
</span>    35    <span class="comment"> *
</span>    36    <span class="comment"> */</span>
    37    
    38    <span class=key>package</span> ti.sysbios.knl;
    39    
    40    import xdc.rov.ViewInfo;
    41    
    42    import xdc.runtime.Assert;
    43    import xdc.runtime.Diags;
    44    import xdc.runtime.Log;
    45    
    46    import ti.sysbios.hal.Timer;
    47    
    48    <span class="xdoc">/*!
</span>    49    <span class="xdoc"> *  ======== Clock ========
</span>    50    <span class="xdoc"> *  System Clock Manager
</span>    51    <span class="xdoc"> *
</span>    52    <span class="xdoc"> *  The System Clock Manager is responsible for all timing services in 
</span>    53    <span class="xdoc"> *  SYS/BIOS.
</span>    54    <span class="xdoc"> *  It generates the periodic system tick. The tick period is configurable.
</span>    55    <span class="xdoc"> *  The timeout and period for all Clock Instances and timeout values in 
</span>    56    <span class="xdoc"> *  other SYS/BIOS modules are specified in terms of Clock ticks.
</span>    57    <span class="xdoc"> *
</span>    58    <span class="xdoc"> *  The Clock Manager supports two tick "modes": a periodic mode with an 
</span>    59    <span class="xdoc"> *  interrupt on each tick (TickMode_PERIODIC), and a tick suppression 
</span>    60    <span class="xdoc"> *  mode (TickMode_DYNAMIC), which reduces the number of timer interrupts to 
</span>    61    <span class="xdoc"> *  the minimum required to support the scheduled timeouts.  For devices that 
</span>    62    <span class="xdoc"> *  support it (e.g., MSP430 devices), TickMode_DYNAMIC may be the default 
</span>    63    <span class="xdoc"> *  mode if one is not specified in the application configuration; otherwise, 
</span>    64    <span class="xdoc"> *  the default mode will be TickMode_PERIODIC.  The following example shows 
</span>    65    <span class="xdoc"> *  how the tick mode  can be specified in the application configuration:
</span>    66    <span class="xdoc"> *
</span>    67    <span class="xdoc"> *  <b>@p(code)</b>
</span>    68    <span class="xdoc"> *  var Clock = xdc.useModule('ti.sysbios.knl.Clock');
</span>    69    <span class="xdoc"> *
</span>    70    <span class="xdoc"> *  // Tell the Clock module to use TickMode_PERIODIC
</span>    71    <span class="xdoc"> *  Clock.tickMode = Clock.TickMode_PERIODIC;
</span>    72    <span class="xdoc"> *  <b>@p</b>
</span>    73    <span class="xdoc"> *
</span>    74    <span class="xdoc"> *  Clock Instances are functions that can be scheduled to run after a 
</span>    75    <span class="xdoc"> *  certain number of Clock ticks.
</span>    76    <span class="xdoc"> *  Clock instances are either one-shot or periodic. Instances are started 
</span>    77    <span class="xdoc"> *  when created or they are started later using the Clock_start()function. 
</span>    78    <span class="xdoc"> *  Instances can be stopped using the Clock_stop() function. All Clock 
</span>    79    <span class="xdoc"> *  Instances are executed when they expire in the context of a software 
</span>    80    <span class="xdoc"> *  interrupt.
</span>    81    <span class="xdoc"> *
</span>    82    <span class="xdoc"> *  Clock objects are placed in the Clock object service list when 
</span>    83    <span class="xdoc"> *  created/constructed and remain there until deleted/destructed.
</span>    84    <span class="xdoc"> *  To minimize processing overhead, unused or expired Clock objects 
</span>    85    <span class="xdoc"> *  should be deleted or destructed.
</span>    86    <span class="xdoc"> *
</span>    87    <span class="xdoc"> *  The getTicks() function returns number of clock ticks since startup.
</span>    88    <span class="xdoc"> *
</span>    89    <span class="xdoc"> *  By default, the Clock module statically configures a 
</span>    90    <span class="xdoc"> *  {<b>@link</b> ti.sysbios.hal.Timer}
</span>    91    <span class="xdoc"> *  timer instance to provide the periodic 1 ms tick interrupt. If you
</span>    92    <span class="xdoc"> *  want to use a custom configured timer for the Clock module's tick source,
</span>    93    <span class="xdoc"> *  use the following example configuration as a guide:
</span>    94    <span class="xdoc"> *
</span>    95    <span class="xdoc"> *  <b>@p(code)</b>
</span>    96    <span class="xdoc"> *  var Clock = xdc.useModule('ti.sysbios.knl.Clock');
</span>    97    <span class="xdoc"> *
</span>    98    <span class="xdoc"> *  // Tell the Clock module that YOU are providing the periodic interrupt
</span>    99    <span class="xdoc"> *  Clock.tickSource = Clock.TickSource_USER;
</span>   100    <span class="xdoc"> *
</span>   101    <span class="xdoc"> *  // this example uses the ti.sysbios.timers.dmtimer.Timer module
</span>   102    <span class="xdoc"> *  var Timer = xdc.useModule('ti.sysbios.timers.dmtimer.Timer');
</span>   103    <span class="xdoc"> *
</span>   104    <span class="xdoc"> *  // create a dmtimer config parameter object
</span>   105    <span class="xdoc"> *  var timerParams = new Timer.Params();
</span>   106    <span class="xdoc"> *
</span>   107    <span class="xdoc"> *  // make sure you set the period to 1000 us (1ms)
</span>   108    <span class="xdoc"> *  timerParams.period = 1000;
</span>   109    <span class="xdoc"> *
</span>   110    <span class="xdoc"> *  // custom dmtimer config parameters here...
</span>   111    <span class="xdoc"> *  timerParams.twer.ovf_wup_ena = 1;
</span>   112    <span class="xdoc"> *
</span>   113    <span class="xdoc"> *  // Create the timer.
</span>   114    <span class="xdoc"> *  // This example uses timer id 3.
</span>   115    <span class="xdoc"> *  // The timer interrupt handler must be set to 'Clock.tick'. 
</span>   116    <span class="xdoc"> *  Timer.create(3, Clock.tick, timerParams);
</span>   117    <span class="xdoc"> *  <b>@p</b>
</span>   118    <span class="xdoc"> *
</span>   119    <span class="xdoc"> *  <b>@p(html)</b>
</span>   120    <span class="xdoc"> *  &lt;h3&gt; Calling Context &lt;/h3&gt;
</span>   121    <span class="xdoc"> *  &lt;table border="1" cellpadding="3"&gt;
</span>   122    <span class="xdoc"> *    &lt;colgroup span="1"&gt;&lt;/colgroup&gt; &lt;colgroup span="5" align="center"&gt;
</span>   123    <span class="xdoc"> *    &lt;/colgroup&gt;
</span>   124    <span class="xdoc"> *
</span>   125    <span class="xdoc"> *    &lt;tr&gt;&lt;th&gt; Function                &lt;/th&gt;&lt;th&gt;  Hwi   &lt;/th&gt;&lt;th&gt;  Swi   &lt;/th&gt;
</span>   126    <span class="xdoc"> *    &lt;th&gt;  Task  &lt;/th&gt;&lt;th&gt;  Main  &lt;/th&gt;&lt;th&gt;  Startup  &lt;/th&gt;&lt;/tr&gt;
</span>   127    <span class="xdoc"> *    &lt;!--                                                                --&gt;
</span>   128    <span class="xdoc"> *    &lt;tr&gt;&lt;td&gt; {<b>@link</b> #construct}      &lt;/td&gt;&lt;td&gt;   N    &lt;/td&gt;&lt;td&gt;   N    &lt;/td&gt;
</span>   129    <span class="xdoc"> *    &lt;td&gt;   Y    &lt;/td&gt;&lt;td&gt;   Y    &lt;/td&gt;&lt;td&gt;   N    &lt;/td&gt;&lt;/tr&gt;
</span>   130    <span class="xdoc"> *    &lt;tr&gt;&lt;td&gt; {<b>@link</b> #create}         &lt;/td&gt;&lt;td&gt;   N    &lt;/td&gt;&lt;td&gt;   N    &lt;/td&gt;
</span>   131    <span class="xdoc"> *    &lt;td&gt;   Y    &lt;/td&gt;&lt;td&gt;   Y    &lt;/td&gt;&lt;td&gt;   N    &lt;/td&gt;&lt;/tr&gt;
</span>   132    <span class="xdoc"> *    &lt;tr&gt;&lt;td&gt; {<b>@link</b> #delete}         &lt;/td&gt;&lt;td&gt;   N    &lt;/td&gt;&lt;td&gt;   N    &lt;/td&gt;
</span>   133    <span class="xdoc"> *    &lt;td&gt;   Y    &lt;/td&gt;&lt;td&gt;   Y    &lt;/td&gt;&lt;td&gt;   N    &lt;/td&gt;&lt;/tr&gt;
</span>   134    <span class="xdoc"> *    &lt;tr&gt;&lt;td&gt; {<b>@link</b> #destruct}       &lt;/td&gt;&lt;td&gt;   N    &lt;/td&gt;&lt;td&gt;   N    &lt;/td&gt;
</span>   135    <span class="xdoc"> *    &lt;td&gt;   Y    &lt;/td&gt;&lt;td&gt;   Y    &lt;/td&gt;&lt;td&gt;   N    &lt;/td&gt;&lt;/tr&gt;
</span>   136    <span class="xdoc"> *    &lt;tr&gt;&lt;td&gt; {<b>@link</b> #getTicks}       &lt;/td&gt;&lt;td&gt;   Y    &lt;/td&gt;&lt;td&gt;   Y    &lt;/td&gt;
</span>   137    <span class="xdoc"> *    &lt;td&gt;   Y    &lt;/td&gt;&lt;td&gt;   N    &lt;/td&gt;&lt;td&gt;   N    &lt;/td&gt;&lt;/tr&gt;
</span>   138    <span class="xdoc"> *    &lt;tr&gt;&lt;td&gt; {<b>@link</b> #getTimeout}     &lt;/td&gt;&lt;td&gt;   Y    &lt;/td&gt;&lt;td&gt;   Y    &lt;/td&gt;
</span>   139    <span class="xdoc"> *    &lt;td&gt;   Y    &lt;/td&gt;&lt;td&gt;   Y    &lt;/td&gt;&lt;td&gt;   N    &lt;/td&gt;&lt;/tr&gt;
</span>   140    <span class="xdoc"> *    &lt;tr&gt;&lt;td&gt; {<b>@link</b> #getTimerHandle} &lt;/td&gt;&lt;td&gt;   Y    &lt;/td&gt;&lt;td&gt;   Y    &lt;/td&gt;
</span>   141    <span class="xdoc"> *    &lt;td&gt;   Y    &lt;/td&gt;&lt;td&gt;   Y    &lt;/td&gt;&lt;td&gt;   Y    &lt;/td&gt;&lt;/tr&gt;
</span>   142    <span class="xdoc"> *    &lt;tr&gt;&lt;td&gt; {<b>@link</b> #Params_init}    &lt;/td&gt;&lt;td&gt;   Y    &lt;/td&gt;&lt;td&gt;   Y    &lt;/td&gt;
</span>   143    <span class="xdoc"> *    &lt;td&gt;   Y    &lt;/td&gt;&lt;td&gt;   Y    &lt;/td&gt;&lt;td&gt;   Y    &lt;/td&gt;&lt;/tr&gt;
</span>   144    <span class="xdoc"> *    &lt;tr&gt;&lt;td&gt; {<b>@link</b> #setFunc}        &lt;/td&gt;&lt;td&gt;   Y    &lt;/td&gt;&lt;td&gt;   Y    &lt;/td&gt;
</span>   145    <span class="xdoc"> *    &lt;td&gt;   Y    &lt;/td&gt;&lt;td&gt;   Y    &lt;/td&gt;&lt;td&gt;   N    &lt;/td&gt;&lt;/tr&gt;
</span>   146    <span class="xdoc"> *    &lt;tr&gt;&lt;td&gt; {<b>@link</b> #setPeriod}      &lt;/td&gt;&lt;td&gt;   Y    &lt;/td&gt;&lt;td&gt;   Y    &lt;/td&gt;
</span>   147    <span class="xdoc"> *    &lt;td&gt;   Y    &lt;/td&gt;&lt;td&gt;   Y    &lt;/td&gt;&lt;td&gt;   N    &lt;/td&gt;&lt;/tr&gt;
</span>   148    <span class="xdoc"> *    &lt;tr&gt;&lt;td&gt; {<b>@link</b> #setTimeout}     &lt;/td&gt;&lt;td&gt;   Y    &lt;/td&gt;&lt;td&gt;   Y    &lt;/td&gt;
</span>   149    <span class="xdoc"> *    &lt;td&gt;   Y    &lt;/td&gt;&lt;td&gt;   Y    &lt;/td&gt;&lt;td&gt;   N    &lt;/td&gt;&lt;/tr&gt;
</span>   150    <span class="xdoc"> *    &lt;tr&gt;&lt;td&gt; {<b>@link</b> #start}          &lt;/td&gt;&lt;td&gt;   Y    &lt;/td&gt;&lt;td&gt;   Y    &lt;/td&gt;
</span>   151    <span class="xdoc"> *    &lt;td&gt;   Y    &lt;/td&gt;&lt;td&gt;   Y    &lt;/td&gt;&lt;td&gt;   N    &lt;/td&gt;&lt;/tr&gt;
</span>   152    <span class="xdoc"> *    &lt;tr&gt;&lt;td&gt; {<b>@link</b> #stop}           &lt;/td&gt;&lt;td&gt;   Y    &lt;/td&gt;&lt;td&gt;   Y    &lt;/td&gt;
</span>   153    <span class="xdoc"> *    &lt;td&gt;   Y    &lt;/td&gt;&lt;td&gt;   Y    &lt;/td&gt;&lt;td&gt;   N    &lt;/td&gt;&lt;/tr&gt;
</span>   154    <span class="xdoc"> *    &lt;tr&gt;&lt;td&gt; {<b>@link</b> #tick}           &lt;/td&gt;&lt;td&gt;   Y    &lt;/td&gt;&lt;td&gt;   Y    &lt;/td&gt;
</span>   155    <span class="xdoc"> *    &lt;td&gt;   Y    &lt;/td&gt;&lt;td&gt;   N    &lt;/td&gt;&lt;td&gt;   N    &lt;/td&gt;&lt;/tr&gt;
</span>   156    <span class="xdoc"> *    &lt;tr&gt;&lt;td&gt; {<b>@link</b> #tickReconfig}   &lt;/td&gt;&lt;td&gt;   Y    &lt;/td&gt;&lt;td&gt;   Y    &lt;/td&gt;
</span>   157    <span class="xdoc"> *    &lt;td&gt;   Y    &lt;/td&gt;&lt;td&gt;   N    &lt;/td&gt;&lt;td&gt;   N    &lt;/td&gt;&lt;/tr&gt;
</span>   158    <span class="xdoc"> *    &lt;tr&gt;&lt;td&gt; {<b>@link</b> #tickStart}      &lt;/td&gt;&lt;td&gt;   Y    &lt;/td&gt;&lt;td&gt;   Y    &lt;/td&gt;
</span>   159    <span class="xdoc"> *    &lt;td&gt;   Y    &lt;/td&gt;&lt;td&gt;   N    &lt;/td&gt;&lt;td&gt;   N    &lt;/td&gt;&lt;/tr&gt;
</span>   160    <span class="xdoc"> *    &lt;tr&gt;&lt;td&gt; {<b>@link</b> #tickStop}       &lt;/td&gt;&lt;td&gt;   Y    &lt;/td&gt;&lt;td&gt;   Y    &lt;/td&gt;
</span>   161    <span class="xdoc"> *    &lt;td&gt;   Y    &lt;/td&gt;&lt;td&gt;   N    &lt;/td&gt;&lt;td&gt;   N    &lt;/td&gt;&lt;/tr&gt;
</span>   162    <span class="xdoc"> *    &lt;tr&gt;&lt;td colspan="6"&gt; Definitions: &lt;br /&gt;
</span>   163    <span class="xdoc"> *       &lt;ul&gt;
</span>   164    <span class="xdoc"> *         &lt;li&gt; &lt;b&gt;Hwi&lt;/b&gt;: API is callable from a Hwi thread. &lt;/li&gt;
</span>   165    <span class="xdoc"> *         &lt;li&gt; &lt;b&gt;Swi&lt;/b&gt;: API is callable from a Swi thread. &lt;/li&gt;
</span>   166    <span class="xdoc"> *         &lt;li&gt; &lt;b&gt;Task&lt;/b&gt;: API is callable from a Task thread. &lt;/li&gt;
</span>   167    <span class="xdoc"> *         &lt;li&gt; &lt;b&gt;Main&lt;/b&gt;: API is callable during any of these phases: &lt;/li&gt;
</span>   168    <span class="xdoc"> *           &lt;ul&gt;
</span>   169    <span class="xdoc"> *             &lt;li&gt; In your module startup after this module is started 
</span>   170    <span class="xdoc"> *    (e.g. Clock_Module_startupDone() returns TRUE). &lt;/li&gt;
</span>   171    <span class="xdoc"> *             &lt;li&gt; During 
</span>   172    <span class="xdoc"> *    {<b>@link</b> xdc.runtime.Startup#lastFxns Startup.lastFxns}. &lt;/li&gt;
</span>   173    <span class="xdoc"> *             &lt;li&gt; During main().&lt;/li&gt;
</span>   174    <span class="xdoc"> *             &lt;li&gt; During 
</span>   175    <span class="xdoc"> *    {<b>@link</b> ti.sysbios.BIOS#startupFxns BIOS.startupFxns}.&lt;/li&gt;
</span>   176    <span class="xdoc"> *           &lt;/ul&gt;
</span>   177    <span class="xdoc"> *         &lt;li&gt; &lt;b&gt;Startup&lt;/b&gt;: API is callable during any of these phases:&lt;/li&gt;
</span>   178    <span class="xdoc"> *           &lt;ul&gt;
</span>   179    <span class="xdoc"> *             &lt;li&gt; During 
</span>   180    <span class="xdoc"> *    {<b>@link</b> xdc.runtime.Startup#firstFxns Startup.firstFxns}.&lt;/li&gt;
</span>   181    <span class="xdoc"> *             &lt;li&gt; In your module startup before this module is started 
</span>   182    <span class="xdoc"> *    (e.g. Clock_Module_startupDone() returns FALSE).&lt;/li&gt;
</span>   183    <span class="xdoc"> *           &lt;/ul&gt;
</span>   184    <span class="xdoc"> *       &lt;/ul&gt;
</span>   185    <span class="xdoc"> *    &lt;/td&gt;&lt;/tr&gt;
</span>   186    <span class="xdoc"> *
</span>   187    <span class="xdoc"> *  &lt;/table&gt;
</span>   188    <span class="xdoc"> *  <b>@p</b>
</span>   189    <span class="xdoc"> */</span>
   190    
   191    @ModuleStartup
   192    @InstanceInitStatic <span class="comment">/* Construct/Destruct CAN becalled at runtime */</span>
   193    @InstanceFinalize   <span class="comment">/* generate call to Clock_Instance_finalize on delete */</span>
   194    @Template(<span class="string">"./Clock.xdt"</span>)
   195    
   196    <span class=key>module</span> Clock
   197    {
   198        <span class="xdoc">/*! 
</span>   199    <span class="xdoc">     *  ======== TickSource ========
</span>   200    <span class="xdoc">     *  Clock tick source
</span>   201    <span class="xdoc">     *
</span>   202    <span class="xdoc">     *  <b>@field(TickSource_TIMER)</b> {<b>@link</b> #tick Clock_tick()} is called
</span>   203    <span class="xdoc">     *  automatically from within a {<b>@link</b> ti.sysbios.hal.Timer} ISR.  The
</span>   204    <span class="xdoc">     *  specific timer and its period can be controlled via {<b>@link</b> #timerId}
</span>   205    <span class="xdoc">     *  and {<b>@link</b> tickPeriod}.
</span>   206    <span class="xdoc">     *
</span>   207    <span class="xdoc">     *  <b>@field(TickSource_USER)</b> {<b>@link</b> #tick Clock_tick()} must be explicitly
</span>   208    <span class="xdoc">     *  called by the user's application.
</span>   209    <span class="xdoc">     *
</span>   210    <span class="xdoc">     *  <b>@field(TickSource_NULL)</b>  {<b>@link</b> #tick Clock_tick()} is never called.
</span>   211    <span class="xdoc">     *  In this case, it is an error for the application to ever call
</span>   212    <span class="xdoc">     *  Clock_tick().
</span>   213    <span class="xdoc">     *
</span>   214    <span class="xdoc">     *  <b>@see</b> #tickPeriod
</span>   215    <span class="xdoc">     *  <b>@see</b> #timerId
</span>   216    <span class="xdoc">     */</span>
   217        <span class=key>enum</span>  TickSource {
   218            TickSource_TIMER,   <span class="xdoc">/*! Use Timer to automatically call Clock_tick() */</span>
   219            TickSource_USER,    <span class="xdoc">/*! Application explicitly calls Clock_tick() */</span>
   220            TickSource_NULL     <span class="xdoc">/*! Clock_tick() is never called */</span>
   221        };
   222    
   223        <span class="xdoc">/*!
</span>   224    <span class="xdoc">     *  ======== TickMode ========
</span>   225    <span class="xdoc">     *  Clock Tick Mode
</span>   226    <span class="xdoc">     */</span>
   227        <span class=key>enum</span>  TickMode {
   228            TickMode_PERIODIC,  <span class="xdoc">/*! Timer will interrupt every period */</span>
   229            TickMode_DYNAMIC    <span class="xdoc">/*! Unnecessary timer ticks can be suppressed (available on subset of devices) */</span>
   230        };
   231    
   232        <span class="xdoc">/*!
</span>   233    <span class="xdoc">     *  ======== BasicView ========
</span>   234    <span class="xdoc">     *  <b>@_nodoc</b>
</span>   235    <span class="xdoc">     */</span>
   236        <span class=key>metaonly</span> <span class=key>struct</span> BasicView {
   237            String          label;
   238            UInt32          timeout;
   239            UInt            period;
   240            String          fxn[];
   241            UArg            arg;
   242            Bool            started;        <span class="comment">/* Instance running? */</span>
   243            String          tRemaining;     <span class="comment">/* Remaining timeout */</span>
   244            Bool            periodic;       <span class="comment">/* Periodic? (vs. one-shot) */</span>
   245        }
   246        
   247        <span class="xdoc">/*!
</span>   248    <span class="xdoc">     *  ======== ModuleView ========
</span>   249    <span class="xdoc">     *  <b>@_nodoc</b>
</span>   250    <span class="xdoc">     */</span>
   251        <span class=key>metaonly</span> <span class=key>struct</span> ModuleView {
   252            String          ticks;
   253            String          tickSource;
   254            String          tickMode;
   255            String          timerHandle;
   256            UInt            timerId;
   257            UInt            swiPriority;
   258            UInt32          tickPeriod;
   259            volatile UInt   nSkip;
   260        }
   261    
   262        <span class="comment">/*
</span>   263    <span class="comment">     *  ======== rovViewInfo ========
</span>   264    <span class="comment">     *  @_nodoc
</span>   265    <span class="comment">     */</span>
   266        @Facet
   267        <span class=key>metaonly</span> <span class=key>config</span> ViewInfo.Instance rovViewInfo = 
   268            ViewInfo.create({
   269                viewMap: [
   270                  [<span class="string">'Basic'</span>,    {type: ViewInfo.INSTANCE, viewInitFxn: <span class="string">'viewInitBasic'</span>,  structName: <span class="string">'BasicView'</span>}],
   271                  [<span class="string">'Module'</span>,   {type: ViewInfo.MODULE,   viewInitFxn: <span class="string">'viewInitModule'</span>, structName: <span class="string">'ModuleView'</span>}],
   272                ]
   273            });
   274            
   275        <span class="xdoc">/*!
</span>   276    <span class="xdoc">     *  ======== FuncPtr ========
</span>   277    <span class="xdoc">     * Instance function prototype
</span>   278    <span class="xdoc">     */</span>
   279        <span class=key>typedef</span> Void (*FuncPtr)(UArg);
   280    
   281        <span class="xdoc">/*!
</span>   282    <span class="xdoc">     *  ======== LW_delayed ========
</span>   283    <span class="xdoc">     *  Logged if Clock Swi delayed by &gt;= 1 tick
</span>   284    <span class="xdoc">     */</span>
   285        <span class=key>config</span> Log.Event LW_delayed = {
   286            mask: Diags.USER3,
   287            msg: <span class="string">"LW_delayed: delay: %d"</span>
   288        };
   289    
   290        <span class="xdoc">/*!
</span>   291    <span class="xdoc">     *  ======== LM_tick ========
</span>   292    <span class="xdoc">     *  Logged in every Clock tick interrupt
</span>   293    <span class="xdoc">     */</span>
   294        <span class=key>config</span> Log.Event LM_tick = {
   295            mask: Diags.USER1 | Diags.USER2,
   296            msg: <span class="string">"LM_tick: tick: %d"</span>
   297        };
   298    
   299        <span class="xdoc">/*!
</span>   300    <span class="xdoc">     *  ======== LM_begin ========
</span>   301    <span class="xdoc">     *  Logged just prior to calling each Clock function
</span>   302    <span class="xdoc">     */</span>
   303        <span class=key>config</span> Log.Event LM_begin = {
   304            mask: Diags.USER1 | Diags.USER2,
   305            msg: <span class="string">"LM_begin: clk: 0x%x, func: 0x%x"</span>
   306        };
   307    
   308        <span class="xdoc">/*!
</span>   309    <span class="xdoc">     *  ======== A_clockDisabled ========
</span>   310    <span class="xdoc">     *  Asserted in Clock_create()
</span>   311    <span class="xdoc">     */</span>
   312        <span class=key>config</span> Assert.Id A_clockDisabled = {
   313            msg: <span class="string">"A_clockDisabled: Cannot create a clock instance when BIOS.clockEnabled is false."</span>
   314        };
   315    
   316        <span class="xdoc">/*!
</span>   317    <span class="xdoc">     *  ======== A_badThreadType ========
</span>   318    <span class="xdoc">     *  Asserted in Clock_create and Clock_delete
</span>   319    <span class="xdoc">     */</span>
   320        <span class=key>config</span> Assert.Id A_badThreadType = {
   321            msg: <span class="string">"A_badThreadType: Cannot create/delete a Clock from Hwi or Swi thread."</span>
   322        };
   323    
   324        <span class="xdoc">/*!
</span>   325    <span class="xdoc">     *  ======== tickSource ========
</span>   326    <span class="xdoc">     *  Source of clock ticks
</span>   327    <span class="xdoc">     *
</span>   328    <span class="xdoc">     *  If this parameter is not set to TickSource_TIMER,
</span>   329    <span class="xdoc">     *  {<b>@link</b> #tickStart Clock_tickStart()},
</span>   330    <span class="xdoc">     *  {<b>@link</b> #tickStop Clock_tickStop()}, and
</span>   331    <span class="xdoc">     *  {<b>@link</b> #tickReconfig Clock_tickReconfig()}, have no effect.
</span>   332    <span class="xdoc">     *
</span>   333    <span class="xdoc">     *  The default is TickSource_TIMER.
</span>   334    <span class="xdoc">     */</span>
   335        <span class=key>config</span> TickSource tickSource = TickSource_TIMER;
   336    
   337        <span class="xdoc">/*!
</span>   338    <span class="xdoc">     *  ======== tickMode ========
</span>   339    <span class="xdoc">     *  Timer tick mode
</span>   340    <span class="xdoc">     *
</span>   341    <span class="xdoc">     *  This parameter specifies the tick mode to be used by the underlying
</span>   342    <span class="xdoc">     *  Timer.  
</span>   343    <span class="xdoc">     *  
</span>   344    <span class="xdoc">     *  With TickMode_PERIODIC the timer will interrupt the CPU at
</span>   345    <span class="xdoc">     *  a fixed rate, defined by the tickPeriod.  
</span>   346    <span class="xdoc">     *
</span>   347    <span class="xdoc">     *  With TickMode_DYNAMIC the timer can be dynamically reprogrammed by 
</span>   348    <span class="xdoc">     *  Clock, to interrupt the CPU when the next tick is actually needed for 
</span>   349    <span class="xdoc">     *  a scheduled timeout. TickMode_DYNAMIC is not supported on all devices,
</span>   350    <span class="xdoc">     *  and may have some application constraints (for example, for MSP430, 
</span>   351    <span class="xdoc">     *  see a description on this wiki page:
</span>   352    <span class="xdoc">     *  http://processors.wiki.ti.com/index.php/SYS/BIOS_for_the_MSP430#Clock_Tick_Suppression).
</span>   353    <span class="xdoc">     */</span>
   354        <span class=key>config</span> TickMode tickMode;
   355    
   356        <span class="xdoc">/*!
</span>   357    <span class="xdoc">     *  ======== timerId ========
</span>   358    <span class="xdoc">     *  Timer Id used to create a Timer instance
</span>   359    <span class="xdoc">     *
</span>   360    <span class="xdoc">     *  If {<b>@link</b> #tickSource Clock.tickSource} is set to TickSource_TIMER,
</span>   361    <span class="xdoc">     *  the Clock module automatically  creates a
</span>   362    <span class="xdoc">     *  {<b>@link</b> ti.sysbios.hal.Timer#create instance} that automatically calls
</span>   363    <span class="xdoc">     *  Clock_doTick() on a periodic basis (as specified by
</span>   364    <span class="xdoc">     *  {<b>@link</b> #tickPeriod tickPeriod} and {<b>@link</b> #periodType periodType}.)
</span>   365    <span class="xdoc">     *
</span>   366    <span class="xdoc">     *  This configuration parameter allows you to control which timer is
</span>   367    <span class="xdoc">     *  used to drive the Clock module.
</span>   368    <span class="xdoc">     *
</span>   369    <span class="xdoc">     *  The default value is {<b>@link</b> ti.sysbios.hal.Timer#ANY Timer.ANY} (~0)
</span>   370    <span class="xdoc">     *  and the maximum timerId possible is family and device specific.
</span>   371    <span class="xdoc">     *
</span>   372    <span class="xdoc">     *  <b>@see</b> ti.sysbios.hal.Timer
</span>   373    <span class="xdoc">     */</span>
   374        <span class=key>config</span> UInt timerId = ~0;
   375    
   376        <span class="xdoc">/*!
</span>   377    <span class="xdoc">     *  ======== swiPriority ========
</span>   378    <span class="xdoc">     *  The priority of Swi used by Clock to process its instances
</span>   379    <span class="xdoc">     *
</span>   380    <span class="xdoc">     *  All Clock instances are executed in the context of a single
</span>   381    <span class="xdoc">     *  {<b>@link</b> Swi}.  This parameter allows you to control the priority of
</span>   382    <span class="xdoc">     *  that Swi.
</span>   383    <span class="xdoc">     *
</span>   384    <span class="xdoc">     *  The default value of this parameter is Swi.numPriorities - 1; i.e.,
</span>   385    <span class="xdoc">     *  the maximum Swi priority.
</span>   386    <span class="xdoc">     *
</span>   387    <span class="xdoc">     *  <b>@see</b> ti.sysbios.knl.Swi#numPriorities
</span>   388    <span class="xdoc">     */</span>
   389        <span class=key>metaonly</span> <span class=key>config</span> UInt swiPriority;
   390    
   391        <span class="xdoc">/*!
</span>   392    <span class="xdoc">     *  ======== tickPeriod ========
</span>   393    <span class="xdoc">     *  Tick period specified in microseconds
</span>   394    <span class="xdoc">     *  
</span>   395    <span class="xdoc">     *  Default value is family dependent. For example, Linux systems often
</span>   396    <span class="xdoc">     *  only support a minimum period of 10000 us and multiples of 10000 us.
</span>   397    <span class="xdoc">     *  TI platforms have a default of 1000 us.
</span>   398    <span class="xdoc">     */</span>
   399        <span class=key>config</span> UInt32 tickPeriod;
   400    
   401        <span class="xdoc">/*!
</span>   402    <span class="xdoc">     *  ======== getTicks ========
</span>   403    <span class="xdoc">     *  Time in Clock ticks
</span>   404    <span class="xdoc">     *
</span>   405    <span class="xdoc">     *  The value returned will wrap back to zero after it reaches the max
</span>   406    <span class="xdoc">     *  value that can be stored in 32 bits.
</span>   407    <span class="xdoc">     *
</span>   408    <span class="xdoc">     *  <b>@b(returns)</b>     time in clock ticks
</span>   409    <span class="xdoc">     */</span>
   410        @DirectCall
   411        UInt32 getTicks();
   412    
   413        <span class="xdoc">/*!
</span>   414    <span class="xdoc">     *  ======== getTimerHandle ========
</span>   415    <span class="xdoc">     *  Get timer Handle
</span>   416    <span class="xdoc">     *
</span>   417    <span class="xdoc">     *  Used when is it necessary to change family 
</span>   418    <span class="xdoc">     *  specific options for the timer and its Hwi Object.
</span>   419    <span class="xdoc">     *
</span>   420    <span class="xdoc">     *  <b>@b(returns)</b>     Timer Handle
</span>   421    <span class="xdoc">     */</span>
   422        @DirectCall
   423        ti.sysbios.hal.Timer.Handle getTimerHandle();
   424    
   425        <span class="xdoc">/*!
</span>   426    <span class="xdoc">     *  ======== tickStop ========
</span>   427    <span class="xdoc">     *  Stop clock for reconfiguration
</span>   428    <span class="xdoc">     *
</span>   429    <span class="xdoc">     *  This function is used to stop the timer used for generation of
</span>   430    <span class="xdoc">     *  clock ticks. It is used along with Clock_tickStart() and 
</span>   431    <span class="xdoc">     *  Clock_tickReconfig() to allow reconfiguration of timer at runtime.
</span>   432    <span class="xdoc">     *
</span>   433    <span class="xdoc">     *  <b>@a(constraints)</b>
</span>   434    <span class="xdoc">     *  This function is non-reentrant and appropriate locks must be used to
</span>   435    <span class="xdoc">     *  protect against  re-entrancy.
</span>   436    <span class="xdoc">     */</span>
   437        @DirectCall
   438        Void tickStop();
   439    
   440        <span class="xdoc">/*!
</span>   441    <span class="xdoc">     *  ======== tickReconfig ========
</span>   442    <span class="xdoc">     *  Reconfigure clock for new cpu frequency
</span>   443    <span class="xdoc">     *  
</span>   444    <span class="xdoc">     *  This function uses the new cpu frequency to reconfigure the timer used 
</span>   445    <span class="xdoc">     *  for generation of clock ticks such that tick period is 
</span>   446    <span class="xdoc">     *  accurate.  This function is used along with Clock_tickStop() and 
</span>   447    <span class="xdoc">     *  Clock_tickStart() to allow reconfiguration of timer at runtime.
</span>   448    <span class="xdoc">     *
</span>   449    <span class="xdoc">     *  When calling Clock_tickReconfig outside of main(), you must also call
</span>   450    <span class="xdoc">     *  Clock_tickStop and Clock_tickStart to stop and restart the timer. 
</span>   451    <span class="xdoc">     *  Use the following call sequence:
</span>   452    <span class="xdoc">     *
</span>   453    <span class="xdoc">     *  <b>@p(code)</b>
</span>   454    <span class="xdoc">     *  // disable interrupts if an interrupt could lead to
</span>   455    <span class="xdoc">     *  // another call to Clock_tickReconfig or if interrupt
</span>   456    <span class="xdoc">     *  // processing relies on having a running timer
</span>   457    <span class="xdoc">     *  Hwi_disable() or Swi_disable();
</span>   458    <span class="xdoc">     *  BIOS_setCpuFreq(&amp;freq);
</span>   459    <span class="xdoc">     *  Clock_tickStop();
</span>   460    <span class="xdoc">     *  Clock_tickReconfig();
</span>   461    <span class="xdoc">     *  Clock_tickStart();
</span>   462    <span class="xdoc">     *  Hwi_restore() or Swi_enable()
</span>   463    <span class="xdoc">     *  <b>@p</b>
</span>   464    <span class="xdoc">     *
</span>   465    <span class="xdoc">     *  When calling Clock_tickReconfig from main(), the timer has not yet
</span>   466    <span class="xdoc">     *  been started because the timer is started as part of BIOS_start().
</span>   467    <span class="xdoc">     *  As a result, you can use the following simplified call sequence 
</span>   468    <span class="xdoc">     *  in main():
</span>   469    <span class="xdoc">     *
</span>   470    <span class="xdoc">     *  <b>@p(code)</b>
</span>   471    <span class="xdoc">     *  BIOS_setCpuFrequency(Types.FreqHz *freq);
</span>   472    <span class="xdoc">     *  Clock_tickReconfig(Void);
</span>   473    <span class="xdoc">     *  <b>@p</b>
</span>   474    <span class="xdoc">     *
</span>   475    <span class="xdoc">     *  The return value is false if the timer cannot support the new 
</span>   476    <span class="xdoc">     *  frequency
</span>   477    <span class="xdoc">     *
</span>   478    <span class="xdoc">     *  <b>@b(returns)</b>     true if successful
</span>   479    <span class="xdoc">     *
</span>   480    <span class="xdoc">     *  <b>@a(constraints)</b>
</span>   481    <span class="xdoc">     *  This function is non-reentrant and appropriate locks must be used to
</span>   482    <span class="xdoc">     *  protect against  re-entrancy.
</span>   483    <span class="xdoc">     */</span>
   484        @DirectCall
   485        Bool tickReconfig();
   486    
   487        <span class="xdoc">/*!
</span>   488    <span class="xdoc">     *  ======== tickStart ========
</span>   489    <span class="xdoc">     *  Start clock after reconfiguration
</span>   490    <span class="xdoc">     *
</span>   491    <span class="xdoc">     *  This function starts the timer used for generation of clock ticks
</span>   492    <span class="xdoc">     *  It is used along with Clock_tickStop() and Clock_tickReconfig() to
</span>   493    <span class="xdoc">     *  allow reconfiguration of timer at runtime. The new timer configuration 
</span>   494    <span class="xdoc">     *  reflects changes caused by a call to reconfig().
</span>   495    <span class="xdoc">     *
</span>   496    <span class="xdoc">     *  <b>@a(constraints)</b>
</span>   497    <span class="xdoc">     *  This function is non-reentrant and appropriate locks must be used to
</span>   498    <span class="xdoc">     *  protect against  re-entrancy.
</span>   499    <span class="xdoc">     */</span>
   500        @DirectCall
   501        Void tickStart();
   502    
   503        <span class="xdoc">/*!
</span>   504    <span class="xdoc">     *  ======== tick ========
</span>   505    <span class="xdoc">     *  Advance Clock time by one tick
</span>   506    <span class="xdoc">     *
</span>   507    <span class="xdoc">     *  After incrementing a global tick counter, this function posts a Swi
</span>   508    <span class="xdoc">     *  that processes the clock instances.
</span>   509    <span class="xdoc">     *
</span>   510    <span class="xdoc">     *  This function is automatically called by a timer ISR when
</span>   511    <span class="xdoc">     *  {<b>@link</b> #tickSource} is set to {<b>@link</b> #TickSource_TIMER}. 
</span>   512    <span class="xdoc">     *
</span>   513    <span class="xdoc">     *  When {<b>@link</b> #tickSource} is set to
</span>   514    <span class="xdoc">     *  {<b>@link</b> #TickSource_USER}, Clock_tick() must be called by the
</span>   515    <span class="xdoc">     *  application.  Usually, this is done within a user defined {<b>@link</b> Hwi},
</span>   516    <span class="xdoc">     *  {<b>@link</b> Swi}, or {<b>@link</b> Task}.
</span>   517    <span class="xdoc">     *
</span>   518    <span class="xdoc">     *  Note that this function is not re-entrant.  The application is
</span>   519    <span class="xdoc">     *  responsible for ensuring that invocations of this function are
</span>   520    <span class="xdoc">     *  serialized: either only one thread in the system ever calls this
</span>   521    <span class="xdoc">     *  function or all calls are "wrapped" by an appropriate mutex.
</span>   522    <span class="xdoc">     *
</span>   523    <span class="xdoc">     *  <b>@see</b> #tickSource
</span>   524    <span class="xdoc">     */</span>
   525        @DirectCall
   526        Void tick();
   527    
   528        <span class="xdoc">/*! 
</span>   529    <span class="xdoc">     *  <b>@_nodoc</b> 
</span>   530    <span class="xdoc">     *  ======== workFunc ========
</span>   531    <span class="xdoc">     *  Clock Q service routine
</span>   532    <span class="xdoc">     *  
</span>   533    <span class="xdoc">     *  <b>@param(arg0)</b>    Unused. required to match Swi.FuncPtr
</span>   534    <span class="xdoc">     *  <b>@param(arg1)</b>    Unused. required to match Swi.FuncPtr
</span>   535    <span class="xdoc">     */</span>
   536        @DirectCall
   537        Void workFunc(UArg arg0, UArg arg1);
   538    
   539        <span class="xdoc">/*! 
</span>   540    <span class="xdoc">     *  <b>@_nodoc</b> 
</span>   541    <span class="xdoc">     *  ======== workFuncDynamic ========
</span>   542    <span class="xdoc">     *  Clock Q service routine for TickMode_DYNAMIC
</span>   543    <span class="xdoc">     *  
</span>   544    <span class="xdoc">     *  <b>@param(arg0)</b>    Unused. required to match Swi.FuncPtr
</span>   545    <span class="xdoc">     *  <b>@param(arg1)</b>    Unused. required to match Swi.FuncPtr
</span>   546    <span class="xdoc">     */</span>
   547        @DirectCall
   548        Void workFuncDynamic(UArg arg0, UArg arg1);
   549    
   550        <span class="xdoc">/*!
</span>   551    <span class="xdoc">     *  <b>@_nodoc</b>
</span>   552    <span class="xdoc">     *  ======= logTick ========
</span>   553    <span class="xdoc">     *  Log the LD_tick from within Clock module scope
</span>   554    <span class="xdoc">     */</span>
   555        @DirectCall
   556        Void logTick();
   557    
   558        <span class="xdoc">/*! 
</span>   559    <span class="xdoc">     *  <b>@_nodoc</b> 
</span>   560    <span class="xdoc">     *  ======== getCompletedTicks ========
</span>   561    <span class="xdoc">     *  Get the number of Clock ticks that have completed
</span>   562    <span class="xdoc">     *
</span>   563    <span class="xdoc">     *  Retuns the number of ticks completed, to the point where
</span>   564    <span class="xdoc">     *  the underlying Timer interrupt has been serviced.  
</span>   565    <span class="xdoc">     * 
</span>   566    <span class="xdoc">     *  <b>@b(returns)</b>     time in clock ticks
</span>   567    <span class="xdoc">     */</span>
   568        @DirectCall
   569        UInt32 getCompletedTicks();
   570    
   571        <span class="xdoc">/*! 
</span>   572    <span class="xdoc">     *  <b>@_nodoc</b> 
</span>   573    <span class="xdoc">     *  ======== getTickPeriod ========
</span>   574    <span class="xdoc">     *  Get the Clock tick period
</span>   575    <span class="xdoc">     *
</span>   576    <span class="xdoc">     *  The period is in units returned by the underlying Timer.
</span>   577    <span class="xdoc">     *
</span>   578    <span class="xdoc">     *  <b>@b(returns)</b>     period in timer counts
</span>   579    <span class="xdoc">     */</span>
   580        @DirectCall
   581        UInt32 getTickPeriod();
   582    
   583        <span class="xdoc">/*!
</span>   584    <span class="xdoc">     *  <b>@_nodoc</b>
</span>   585    <span class="xdoc">     *  ======= setupTimerToSkipTicks ========
</span>   586    <span class="xdoc">     *  Reprogram Clock's Timer to suppress unnecessary tick interrupts 
</span>   587    <span class="xdoc">     */</span>
   588        @DirectCall
   589        Void setupTimerToSkipTicks(UInt skips);
   590    
   591    <span class=key>instance</span>:
   592    
   593        <span class="xdoc">/*!
</span>   594    <span class="xdoc">     *  ======== create ========
</span>   595    <span class="xdoc">     *  Creates a Clock Instance
</span>   596    <span class="xdoc">     *
</span>   597    <span class="xdoc">     *  The first argument is the function that gets called when the timeout 
</span>   598    <span class="xdoc">     *  expires.
</span>   599    <span class="xdoc">     *
</span>   600    <span class="xdoc">     *  The 'timeout' argument is used to specify the initial timeout 
</span>   601    <span class="xdoc">     *  for both one-shot and periodic Clock instances (in Clock ticks).
</span>   602    <span class="xdoc">     *
</span>   603    <span class="xdoc">     *  The {<b>@link</b> #period} parameter is used to set the subsequent timeout
</span>   604    <span class="xdoc">     *  interval (in Clock ticks) for periodic instances. 
</span>   605    <span class="xdoc">     *
</span>   606    <span class="xdoc">     *  For one-shot instances, the period parameter must be set to zero.
</span>   607    <span class="xdoc">     *
</span>   608    <span class="xdoc">     *  When instances are created they are placed upon a linked list managed
</span>   609    <span class="xdoc">     *  by the Clock module.  For this reason, instances cannot be created
</span>   610    <span class="xdoc">     *  from either Hwi or Swi context.
</span>   611    <span class="xdoc">     *
</span>   612    <span class="xdoc">     *  <b>@param(clockFxn)</b>  Function that runs upon timeout
</span>   613    <span class="xdoc">     *  <b>@param(timeout)</b>   One-shot timeout or initial start delay (in clock
</span>   614    <span class="xdoc">     *                    ticks)
</span>   615    <span class="xdoc">     */</span>
   616        @DirectCall
   617        create(FuncPtr clockFxn, UInt timeout);
   618    
   619        <span class="xdoc">/*!
</span>   620    <span class="xdoc">     *  ======== startFlag ========
</span>   621    <span class="xdoc">     *  Start immediately after instance is created
</span>   622    <span class="xdoc">     *
</span>   623    <span class="xdoc">     *  When this flag is set to false, the user will have to call 
</span>   624    <span class="xdoc">     *  Clock_start() to start the instance.
</span>   625    <span class="xdoc">     *     
</span>   626    <span class="xdoc">     *  When set to true, both statically created Clock objects and Clock
</span>   627    <span class="xdoc">     *  objects created in main() are started at the end of main() when the 
</span>   628    <span class="xdoc">     *  user calls BIOS_start(). Dynamically created Clock objects created 
</span>   629    <span class="xdoc">     *  after main() (ie within a task) will be started immediately. 
</span>   630    <span class="xdoc">     *
</span>   631    <span class="xdoc">     *  The default setting for this parameter is false.
</span>   632    <span class="xdoc">     *
</span>   633    <span class="xdoc">     *  The configured Clock function will be called initially after an 
</span>   634    <span class="xdoc">     *  interval equal to the 'timeout' argument for both one-shot and 
</span>   635    <span class="xdoc">     *  periodic Clock objects. 
</span>   636    <span class="xdoc">     *
</span>   637    <span class="xdoc">     *  Periodic Clock objects will subsequently be called at the rate 
</span>   638    <span class="xdoc">     *  specified by the {<b>@link</b> #period} parameter.
</span>   639    <span class="xdoc">     *
</span>   640    <span class="xdoc">     */</span>
   641        <span class=key>config</span> Bool startFlag = <span class=key>false</span>;
   642    
   643        <span class="xdoc">/*!
</span>   644    <span class="xdoc">     *  ======== period ========
</span>   645    <span class="xdoc">     *  Period of this instance (in clock ticks)
</span>   646    <span class="xdoc">     *
</span>   647    <span class="xdoc">     *  The default value of this parameter is 0, which indicates this is
</span>   648    <span class="xdoc">     *  a one-shot Clock object.
</span>   649    <span class="xdoc">     *
</span>   650    <span class="xdoc">     *  A non zero value for this parameter specifies that the Clock
</span>   651    <span class="xdoc">     *  object is to be called periodically, and also specifies the 
</span>   652    <span class="xdoc">     *  rate (in Clock ticks) that the Clock function will be called
</span>   653    <span class="xdoc">     *  AFTER the initial 'timeout' argument period.
</span>   654    <span class="xdoc">     * 
</span>   655    <span class="xdoc">     *  For one-shot Clock instances, this parameter must be set to zero.
</span>   656    <span class="xdoc">     */</span>
   657        <span class=key>config</span> UInt period = 0;
   658    
   659        <span class="xdoc">/*!
</span>   660    <span class="xdoc">     *  ======== arg ========
</span>   661    <span class="xdoc">     *  Uninterpreted argument passed to instance function
</span>   662    <span class="xdoc">     *
</span>   663    <span class="xdoc">     *  The default is null.
</span>   664    <span class="xdoc">     */</span>
   665        <span class=key>config</span> UArg arg = <span class=key>null</span>;
   666    
   667        <span class="xdoc">/*!
</span>   668    <span class="xdoc">     *  ======== start ========
</span>   669    <span class="xdoc">     *  Start instance
</span>   670    <span class="xdoc">     *
</span>   671    <span class="xdoc">     *  The {<b>@link</b> #timeout} and {<b>@link</b> #period} values set during create() 
</span>   672    <span class="xdoc">     *  or by calling Clock_setTimeout() and Clock_setPeriod() are used and 
</span>   673    <span class="xdoc">     *  the expiry is recomputed. 
</span>   674    <span class="xdoc">     *  Note that for periodic instances, the first expiry is 
</span>   675    <span class="xdoc">     *  computed using the timeout specified. All subsequent expiries use the 
</span>   676    <span class="xdoc">     *  period value. 
</span>   677    <span class="xdoc">     *
</span>   678    <span class="xdoc">     *  <b>@a(constraints)</b>
</span>   679    <span class="xdoc">     *  Timeout of instance cannot be zero
</span>   680    <span class="xdoc">     */</span>
   681        @DirectCall
   682        Void start();
   683    
   684        <span class="xdoc">/*!
</span>   685    <span class="xdoc">     *  <b>@_nodoc</b>
</span>   686    <span class="xdoc">     *  ======== startI ========
</span>   687    <span class="xdoc">     *  Internal start function which assumes Hwis disabled
</span>   688    <span class="xdoc">     */</span>
   689        @DirectCall
   690        Void startI();
   691    
   692        <span class="xdoc">/*!
</span>   693    <span class="xdoc">     *  ======== stop ========
</span>   694    <span class="xdoc">     *  Stop instance
</span>   695    <span class="xdoc">     */</span>
   696        @DirectCall
   697        Void stop();
   698    
   699        <span class="xdoc">/*!
</span>   700    <span class="xdoc">     *  ======== setPeriod ========
</span>   701    <span class="xdoc">     *  Set periodic interval
</span>   702    <span class="xdoc">     * 
</span>   703    <span class="xdoc">     *  <b>@param(period)</b>          periodic interval in Clock ticks
</span>   704    <span class="xdoc">     * 
</span>   705    <span class="xdoc">     *  <b>@a(constraints)</b>
</span>   706    <span class="xdoc">     *  Cannot change period of instance that has been started.
</span>   707    <span class="xdoc">     */</span>
   708        @DirectCall
   709        Void setPeriod(UInt period);
   710    
   711        <span class="xdoc">/*!
</span>   712    <span class="xdoc">     *  ======== setTimeout ========
</span>   713    <span class="xdoc">     *  Set the initial timeout
</span>   714    <span class="xdoc">     *
</span>   715    <span class="xdoc">     *  <b>@param(timeout)</b>         initial timeout in Clock ticks
</span>   716    <span class="xdoc">     *
</span>   717    <span class="xdoc">     *  <b>@a(constraints)</b>
</span>   718    <span class="xdoc">     *  Cannot change the initial timeout of instance that has been started.
</span>   719    <span class="xdoc">     */</span>
   720        @DirectCall
   721        Void setTimeout(UInt timeout);
   722    
   723        <span class="xdoc">/*!
</span>   724    <span class="xdoc">     *  ======== setFunc ========
</span>   725    <span class="xdoc">     *  Overwrite Clock function and arg
</span>   726    <span class="xdoc">     *
</span>   727    <span class="xdoc">     *  Replaces a Clock object's clockFxn function originally
</span>   728    <span class="xdoc">     *  provided in {<b>@link</b> #create}.
</span>   729    <span class="xdoc">     *
</span>   730    <span class="xdoc">     *  <b>@param(clockFxn)</b>        function of type FuncPtr
</span>   731    <span class="xdoc">     *  <b>@param(arg)</b>             argument to clockFxn
</span>   732    <span class="xdoc">     *
</span>   733    <span class="xdoc">     *  <b>@a(constraints)</b>
</span>   734    <span class="xdoc">     *  Cannot change function and arg of Clock object that has been started.
</span>   735    <span class="xdoc">     */</span>
   736        @DirectCall
   737        Void setFunc(FuncPtr fxn, UArg arg);
   738    
   739        <span class="xdoc">/*!
</span>   740    <span class="xdoc">     *  ======== getPeriod ========
</span>   741    <span class="xdoc">     *  Get period of instance
</span>   742    <span class="xdoc">     *
</span>   743    <span class="xdoc">     *  Returns the period of an instance.
</span>   744    <span class="xdoc">     *
</span>   745    <span class="xdoc">     *  <b>@b(returns)</b>             returns periodic interval in Clock ticks
</span>   746    <span class="xdoc">     */</span>
   747        @DirectCall
   748        UInt getPeriod();
   749    
   750        <span class="xdoc">/*!
</span>   751    <span class="xdoc">     *  ======== getTimeout ========
</span>   752    <span class="xdoc">     *  Get timeout of instance
</span>   753    <span class="xdoc">     *
</span>   754    <span class="xdoc">     *  Returns the remaining time if instance has been started.
</span>   755    <span class="xdoc">     *
</span>   756    <span class="xdoc">     *  <b>@b(returns)</b>             returns timeout in clock ticks
</span>   757    <span class="xdoc">     */</span>
   758        @DirectCall
   759        UInt getTimeout();
   760    
   761    <span class=key>internal</span>:
   762    
   763        <span class="xdoc">/*!
</span>   764    <span class="xdoc">     *  ======== doTick ========
</span>   765    <span class="xdoc">     *  Function called by the timer interrupt handler
</span>   766    <span class="xdoc">     *
</span>   767    <span class="xdoc">     *  <b>@param(arg)</b>     Unused. Required to match signature of Hwi.FuncPtr
</span>   768    <span class="xdoc">     */</span>
   769        Void doTick(UArg arg);
   770    
   771        <span class="comment">/*
</span>   772    <span class="comment">     *  ======== Instance_State ========
</span>   773    <span class="comment">     */</span>
   774        <span class=key>struct</span> Instance_State {
   775            Queue.Elem      elem;           <span class=comment>// required for clock queue</span>
   776            UInt32          timeout;        <span class=comment>// in clock ticks</span>
   777            UInt32          currTimeout;    <span class=comment>// working timeout</span>
   778            UInt32          period;         <span class=comment>// periodic instance if &gt; 0</span>
   779            volatile Bool   active;         <span class=comment>// active/idle flag</span>
   780            FuncPtr         fxn;            <span class=comment>// instance function</span>
   781            UArg            arg;            <span class=comment>// function arg</span>
   782        };
   783    
   784        <span class="comment">/*
</span>   785    <span class="comment">     *  ======== Module_State ========
</span>   786    <span class="comment">     */</span>
   787        <span class=key>struct</span> Module_State {
   788            volatile UInt32 ticks;          <span class=comment>// ticks</span>
   789            UInt            swiCount;       <span class=comment>// num of Swi posts before Swi runs</span>
   790            Timer.Handle    timer;          <span class=comment>// timer used</span>
   791                                            <span class=comment>// points to generated Clock_doTick()</span>
   792            Queue.Object    clockQ;         <span class=comment>// clock que</span>
   793            Swi.Handle      swi;            <span class=comment>// clock swi</span>
   794            UInt32          periodCounts;   <span class=comment>// clock tick period in timer counts</span>
   795            volatile UInt   numTickSkip;    <span class=comment>// number of ticks being suppressed</span>
   796            UInt32          skipsWorkFunc;  <span class=comment>// new skips reg'd during workFunc</span>
   797            Bool            inWorkFunc;     <span class=comment>// true if in Clock Swi servicing Q</span>
   798        };
   799    }
   800    <span class="comment">/*
</span>   801    <span class="comment"> *  @(#) ti.sysbios.knl; 2, 0, 0, 0,580; 11-7-2012 12:42:24; /db/vtree/library/trees/avala/avala-r22x/src/ xlibrary
</span>   802    <span class="comment">
</span>   803    <span class="comment"> */</span>
   804    
</pre>
</body></html>
